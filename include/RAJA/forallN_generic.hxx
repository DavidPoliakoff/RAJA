//AUTOGENERATED BY gen_forallN_generic.py
/*
 * Copyright (c) 2016, Lawrence Livermore National Security, LLC.
 * Produced at the Lawrence Livermore National Laboratory.
 *
 * All rights reserved.
 *
 * This source code cannot be distributed without permission and
 * further review from Lawrence Livermore National Laboratory.
 */
  
#ifndef RAJA_forallN_generic_HXX__
#define RAJA_forallN_generic_HXX__

#include"config.hxx"
#include"int_datatypes.hxx"

namespace RAJA {



/******************************************************************
 *  ForallN generic policies
 ******************************************************************/

// Execute (Termination default)
struct Forall2_Execute_Tag {};
struct Forall2_Execute {
  typedef Forall2_Execute_Tag PolicyTag;
};

// Starting (outer) policy for all forall2 policies
template<typename POL_I, typename POL_J, typename NEXT=Forall2_Execute>
struct Forall2_Policy {
  typedef NEXT NextPolicy;
  typedef POL_I PolicyI;
  typedef POL_J PolicyJ;
};

// Execute (Termination default)
struct Forall3_Execute_Tag {};
struct Forall3_Execute {
  typedef Forall3_Execute_Tag PolicyTag;
};

// Starting (outer) policy for all forall3 policies
template<typename POL_I, typename POL_J, typename POL_K, typename NEXT=Forall3_Execute>
struct Forall3_Policy {
  typedef NEXT NextPolicy;
  typedef POL_I PolicyI;
  typedef POL_J PolicyJ;
  typedef POL_K PolicyK;
};

// Execute (Termination default)
struct Forall4_Execute_Tag {};
struct Forall4_Execute {
  typedef Forall4_Execute_Tag PolicyTag;
};

// Starting (outer) policy for all forall4 policies
template<typename POL_I, typename POL_J, typename POL_K, typename POL_L, typename NEXT=Forall4_Execute>
struct Forall4_Policy {
  typedef NEXT NextPolicy;
  typedef POL_I PolicyI;
  typedef POL_J PolicyJ;
  typedef POL_K PolicyK;
  typedef POL_L PolicyL;
};

// Execute (Termination default)
struct Forall5_Execute_Tag {};
struct Forall5_Execute {
  typedef Forall5_Execute_Tag PolicyTag;
};

// Starting (outer) policy for all forall5 policies
template<typename POL_I, typename POL_J, typename POL_K, typename POL_L, typename POL_M, typename NEXT=Forall5_Execute>
struct Forall5_Policy {
  typedef NEXT NextPolicy;
  typedef POL_I PolicyI;
  typedef POL_J PolicyJ;
  typedef POL_K PolicyK;
  typedef POL_L PolicyL;
  typedef POL_M PolicyM;
};




/******************************************************************
 *  forallN_policy() Foreward declarations
 ******************************************************************/


template<typename POLICY, typename PolicyI, typename PolicyJ, typename TI, typename TJ, typename BODY, typename TAG>
RAJA_INLINE void forall2_policy(TAG, TI const &is_i, TJ const &is_j, BODY body);

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename TI, typename TJ, typename TK, typename BODY, typename TAG>
RAJA_INLINE void forall3_policy(TAG, TI const &is_i, TJ const &is_j, TK const &is_k, BODY body);

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY, typename TAG>
RAJA_INLINE void forall4_policy(TAG, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body);

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename PolicyM, typename TI, typename TJ, typename TK, typename TL, typename TM, typename BODY, typename TAG>
RAJA_INLINE void forall5_policy(TAG, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, TM const &is_m, BODY body);

/******************************************************************
 *  ForallNExecutor(): Default Executors for loops
 ******************************************************************/

template<typename BODY>
struct Forall2Inner {

	BODY const &body;
  Index_type const i;

	Forall2Inner(BODY const &b, Index_type i0) : body(b), i(i0) {}

	inline void operator()(Index_type j) const {
		body(i,j);
	}
};

template<typename POLICY_J, typename IS_J, typename BODY>
struct Forall2Outer {

	BODY const &body;
	IS_J const &is_j;

	Forall2Outer(BODY const &b, IS_J const &is_j0) : body(b), is_j(is_j0) {}

	inline void operator()(Index_type i) const {	
	  Forall2Inner<BODY> inner(body, i);
		RAJA::forall<POLICY_J>(is_j, inner);
	}
};

template<typename POLICY_I, typename POLICY_J, typename TI, typename TJ>
struct Forall2Executor {
  TI const &is_i;
  TJ const &is_j;
  
  Forall2Executor(TI const &is_i0, TJ const &is_j0) : is_i(is_i0), is_j(is_j0) {}

  template<typename BODY>
  inline void operator()(BODY body) const {

    Forall2Outer<POLICY_J, TJ, BODY> outer(body, is_j);
      
    RAJA::forall<POLICY_I>(is_i, outer); 
  }
};




template<typename BODY>
struct ForallN_BindOuter {

	BODY const &body;
  Index_type const i;

	ForallN_BindOuter(BODY const &b, Index_type i0) : body(b), i(i0) {}

	template<typename ... ARGS>
	inline void operator()(ARGS ... args) const {
	  body(i, args...);
	}
};

template<typename NextExec, typename BODY>
struct ForallN_Outer {

	NextExec const &next_exec;
	BODY const &body;

	explicit ForallN_Outer(NextExec const &ne, BODY const &b) : next_exec(ne), body(b) {}

	inline void operator()(Index_type i) const {
	  ForallN_BindOuter<BODY> inner(body, i);
	  next_exec(inner);
	}
};



template<typename POLICY_I, typename POLICY_J, typename POLICY_K, typename TI, typename TJ, typename TK>
struct Forall3Executor {  

  typedef Forall2Executor<POLICY_J, POLICY_K, TJ, TK> NextExec;
  
  TI const &is_i;
  NextExec next_exec;
    
  Forall3Executor(TI const &is_i0, TJ const &is_j0, TK const &is_k0) : is_i(is_i0), next_exec(is_j0, is_k0) {}

  template<typename BODY>
  inline void operator()(BODY body) const {
    ForallN_Outer<NextExec, BODY> outer(next_exec, body);
    RAJA::forall<POLICY_I>(is_i, outer);
  }
};




template<typename POLICY_I, typename POLICY_J, typename POLICY_K, typename POLICY_L, typename TI, typename TJ, typename TK, typename TL>
struct Forall4Executor {

  typedef Forall3Executor<POLICY_J, POLICY_K, POLICY_L, TJ, TK, TL> NextExec;
  
  TI const &is_i;
  NextExec next_exec;
    
  Forall4Executor(TI const &is_i0, TJ const &is_j0, TK const &is_k0, TL const &is_l0) : is_i(is_i0), next_exec(is_j0, is_k0, is_l0) {}


  template<typename BODY>
  inline void operator()(BODY body) const {
    ForallN_Outer<NextExec, BODY> outer(next_exec, body);
    RAJA::forall<POLICY_I>(is_i, outer);
  }
  
};


/******************************************************************
 *  forallN_policy(), base execution policiess
 ******************************************************************/


/*!
 * \brief Execute inner loops policy function.
 *
 * This is the default termination case.
 */
template<typename POLICY, typename PolicyI, typename PolicyJ, typename TI, typename TJ, typename BODY>
RAJA_INLINE void forall2_policy(Forall2_Execute_Tag, TI const &is_i, TJ const &is_j, BODY body){

  // Create executor object to launch loops
  Forall2Executor<PolicyI, PolicyJ, TI, TJ> exec(is_i, is_j);

  // Launch loop body
  exec(body);
}




/*!
 * \brief Execute inner loops policy function.
 *
 * This is the default termination case.
 */
template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename TI, typename TJ, typename TK, typename BODY>
RAJA_INLINE void forall3_policy(Forall3_Execute_Tag, TI const &is_i, TJ const &is_j, TK const &is_k, BODY body){

  // Create executor object to launch loops
  Forall3Executor<PolicyI, PolicyJ, PolicyK, TI, TJ, TK> exec(is_i, is_j, is_k);

  // Launch loop body
  exec(body);
}




/*!
 * \brief Execute inner loops policy function.
 *
 * This is the default termination case.
 */
template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_policy(Forall4_Execute_Tag, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){

  // Create executor object to launch loops
  Forall4Executor<PolicyI, PolicyJ, PolicyK, PolicyL, TI, TJ, TK, TL> exec(is_i, is_j, is_k, is_l);

  // Launch loop body
  exec(body);
}





/******************************************************************
 *  forallN User API
 ******************************************************************/


template<typename IdxI, typename IdxJ, typename BODY>
struct Lambda2_Functor {

  Lambda2_Functor(BODY const &b) : body(b) {}

  // call 'policy' layer with next policy
  inline void RAJA_HOST_DEVICE operator()(Index_type i, Index_type j) const {
    body(IdxI(i), IdxJ(j));
  }

  // Copy of loop body
  BODY const &body;
};


template<typename IdxI, typename IdxJ, typename IdxK, typename BODY>
struct Lambda3_Functor {

  Lambda3_Functor(BODY const &b) : body(b) {}

  // call 'policy' layer with next policy
  inline void RAJA_HOST_DEVICE operator()(Index_type i, Index_type j, Index_type k) const {
    body(IdxI(i), IdxJ(j), IdxK(k));
  }

  // Copy of loop body
  BODY const &body;
};

template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename BODY>
struct Lambda4_Functor {

  Lambda4_Functor(BODY const &b) : body(b) {}

  // call 'policy' layer with next policy
  inline void RAJA_HOST_DEVICE operator()(Index_type i, Index_type j, Index_type k, Index_type l) const {
    body(IdxI(i), IdxJ(j), IdxK(k), IdxL(l));
  }

  // Copy of loop body
  BODY const &body;
};



/*!
 * \brief Provides abstraction of a 2-nested loop
 *
 * Provides index typing, and initial nested policy unwrapping
 */
template<typename POLICY, typename IdxI=Index_type, typename IdxJ=Index_type, typename TI, typename TJ, typename BODY>
RAJA_INLINE void forall2(TI const &is_i, TJ const &is_j, BODY body){
  // extract next policy
  typedef typename POLICY::NextPolicy             NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag  NextPolicyTag;

  // extract each loop's execution policy
  typedef typename POLICY::PolicyI                PolicyI;
  typedef typename POLICY::PolicyJ                PolicyJ;

  // call 'policy' layer with next policy
  Lambda2_Functor<IdxI, IdxJ, BODY> lamb(body);
  forall2_policy<NextPolicy, PolicyI, PolicyJ>(NextPolicyTag(), is_i, is_j, lamb);
}

/*!
 * \brief Provides abstraction of a 3-nested loop
 *
 * Provides index typing, and initial nested policy unwrapping
 */
template<typename POLICY, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxK=Index_type, typename TI, typename TJ, typename TK, typename BODY>
RAJA_INLINE void forall3(TI const &is_i, TJ const &is_j, TK const &is_k, BODY body){
  // extract next policy
  typedef typename POLICY::NextPolicy             NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag  NextPolicyTag;

  // extract each loop's execution policy
  typedef typename POLICY::PolicyI                PolicyI;
  typedef typename POLICY::PolicyJ                PolicyJ;
  typedef typename POLICY::PolicyK                PolicyK;

  // call 'policy' layer with next policy
  Lambda3_Functor<IdxI, IdxJ, IdxK, BODY> lamb(body);
  forall3_policy<NextPolicy, PolicyI, PolicyJ, PolicyK>(NextPolicyTag(), is_i, is_j, is_k, lamb);
}

/*!
 * \brief Provides abstraction of a 4-nested loop
 *
 * Provides index typing, and initial nested policy unwrapping
 */
template<typename POLICY, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxK=Index_type, typename IdxL=Index_type, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4(TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  // extract next policy
  typedef typename POLICY::NextPolicy             NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag  NextPolicyTag;

  // extract each loop's execution policy
  typedef typename POLICY::PolicyI                PolicyI;
  typedef typename POLICY::PolicyJ                PolicyJ;
  typedef typename POLICY::PolicyK                PolicyK;
  typedef typename POLICY::PolicyL                PolicyL;

  // call 'policy' layer with next policy
  Lambda4_Functor<IdxI, IdxJ, IdxK, IdxL, BODY> lamb(body);
  forall4_policy<NextPolicy, PolicyI, PolicyJ, PolicyK, PolicyL>(NextPolicyTag(), is_i, is_j, is_k, is_l, lamb);
}





} // namespace RAJA
  
#endif

