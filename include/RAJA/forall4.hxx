//AUTOGENERATED BY genForallN.py
/*
 * Copyright (c) 2016, Lawrence Livermore National Security, LLC.
 * Produced at the Lawrence Livermore National Laboratory.
 *
 * All rights reserved.
 *
 * This source code cannot be distributed without permission and
 * further review from Lawrence Livermore National Laboratory.
 */
  
#ifndef RAJA_DOMAIN_FORALL4_HXX__
#define RAJA_DOMAIN_FORALL4_HXX__

#include<RAJA/RAJA.hxx>
#include<RAJA/Tile.hxx>

namespace RAJA {



/******************************************************************
 *  Policy base class, forall4()
 ******************************************************************/

// Execute (Termination default)
struct Forall4_Execute_Tag {};
struct Forall4_Execute {
  typedef Forall4_Execute_Tag PolicyTag;
};

// Starting (outer) policy for all forall4 policies
template<typename POL_I=RAJA::seq_exec, typename POL_J=RAJA::seq_exec, typename POL_K=RAJA::seq_exec, typename POL_L=RAJA::seq_exec, typename NEXT=Forall4_Execute>
struct Forall4_Policy {
  typedef NEXT NextPolicy;
  typedef POL_I PolicyI;
  typedef POL_J PolicyJ;
  typedef POL_K PolicyK;
  typedef POL_L PolicyL;
};

// Interchange loop order given permutation
struct Forall4_Permute_Tag {};
template<typename LOOP_ORDER, typename NEXT=Forall4_Execute>
struct Forall4_Permute {
  typedef Forall4_Permute_Tag PolicyTag;
  typedef NEXT NextPolicy;
  typedef LOOP_ORDER LoopOrder;
};

// Begin OpenMP Parallel Region
struct Forall4_OMP_Parallel_Tag {};
template<typename NEXT=Forall4_Execute>
struct Forall4_OMP_Parallel {
  typedef Forall4_OMP_Parallel_Tag PolicyTag;
  typedef NEXT NextPolicy;
};

// Tiling Policy
struct Forall4_Tile_Tag {};
template<typename TILE_I, typename TILE_J, typename TILE_K, typename TILE_L, typename NEXT=Forall4_Execute>
struct Forall4_Tile {
  typedef Forall4_Tile_Tag PolicyTag;
  typedef NEXT NextPolicy;
  typedef TILE_I TileI;
  typedef TILE_J TileJ;
  typedef TILE_K TileK;
  typedef TILE_L TileL;
};


/******************************************************************
 *  forall4_policy() Foreward declarations
 ******************************************************************/

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_policy(Forall4_Execute_Tag, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body);

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_policy(Forall4_Permute_Tag, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body);

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_policy(Forall4_OMP_Parallel_Tag, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body);

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_policy(Forall4_Tile_Tag, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body);


/******************************************************************
 *  Forall4Executor(): Default Executor for loops
 ******************************************************************/

template<typename POLICY_I, typename POLICY_J, typename POLICY_K, typename POLICY_L, typename TI, typename TJ, typename TK, typename TL>
struct Forall4Executor {
  template<typename BODY>
  inline void operator()(TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body) const {
    RAJA::forall<POLICY_I>(is_i, RAJA_LAMBDA(Index_type i){
      exec(is_j, is_k, is_l, RAJA_LAMBDA(Index_type j, Index_type k, Index_type l){
        body(i, j, k, l);
      });
    });
  }

  private:
    Forall3Executor<POLICY_J, POLICY_K, POLICY_L, TJ, TK, TL> exec;
};


/******************************************************************
 *  OpenMP Auto-Collapsing Executors for forall4()
 ******************************************************************/

#ifdef _OPENMP

// OpenMP Executor with collapse(2) for omp_parallel_for_exec
template<typename POLICY_K, typename POLICY_L, typename TK, typename TL>
class Forall4Executor<RAJA::omp_parallel_for_exec, RAJA::omp_parallel_for_exec, POLICY_K, POLICY_L, RAJA::RangeSegment, RAJA::RangeSegment, TK, TL> {
  public:  
    template<typename BODY>
    inline void operator()(RAJA::RangeSegment const &is_i, RAJA::RangeSegment const &is_j, TK const &is_k, TL const &is_l, BODY body) const {
      Index_type const i_start = is_i.getBegin();
      Index_type const i_end   = is_i.getEnd();

      Index_type const j_start = is_j.getBegin();
      Index_type const j_end   = is_j.getEnd();

#pragma omp parallel for schedule(static) collapse(2)
      for(Index_type i = i_start;i < i_end;++ i){
        for(Index_type j = j_start;j < j_end;++ j){
          exec(is_k, is_l, RAJA_LAMBDA(Index_type k, Index_type l){
            body(i, j, k, l);
          });
      } } 
    }

  private:
    Forall2Executor<POLICY_K, POLICY_L, TK, TL> exec;
};

// OpenMP Executor with collapse(3) for omp_parallel_for_exec
template<typename POLICY_L, typename TL>
class Forall4Executor<RAJA::omp_parallel_for_exec, RAJA::omp_parallel_for_exec, RAJA::omp_parallel_for_exec, POLICY_L, RAJA::RangeSegment, RAJA::RangeSegment, RAJA::RangeSegment, TL> {
  public:  
    template<typename BODY>
    inline void operator()(RAJA::RangeSegment const &is_i, RAJA::RangeSegment const &is_j, RAJA::RangeSegment const &is_k, TL const &is_l, BODY body) const {
      Index_type const i_start = is_i.getBegin();
      Index_type const i_end   = is_i.getEnd();

      Index_type const j_start = is_j.getBegin();
      Index_type const j_end   = is_j.getEnd();

      Index_type const k_start = is_k.getBegin();
      Index_type const k_end   = is_k.getEnd();

#pragma omp parallel for schedule(static) collapse(3)
      for(Index_type i = i_start;i < i_end;++ i){
        for(Index_type j = j_start;j < j_end;++ j){
          for(Index_type k = k_start;k < k_end;++ k){
            RAJA::forall<POLICY_L>(is_l, RAJA_LAMBDA(Index_type l){
              body(i, j, k, l);
            });
      } } } 
    }
};

// OpenMP Executor with collapse(4) for omp_parallel_for_exec
template<>
class Forall4Executor<RAJA::omp_parallel_for_exec, RAJA::omp_parallel_for_exec, RAJA::omp_parallel_for_exec, RAJA::omp_parallel_for_exec, RAJA::RangeSegment, RAJA::RangeSegment, RAJA::RangeSegment, RAJA::RangeSegment> {
  public:  
    template<typename BODY>
    inline void operator()(RAJA::RangeSegment const &is_i, RAJA::RangeSegment const &is_j, RAJA::RangeSegment const &is_k, RAJA::RangeSegment const &is_l, BODY body) const {
      Index_type const i_start = is_i.getBegin();
      Index_type const i_end   = is_i.getEnd();

      Index_type const j_start = is_j.getBegin();
      Index_type const j_end   = is_j.getEnd();

      Index_type const k_start = is_k.getBegin();
      Index_type const k_end   = is_k.getEnd();

      Index_type const l_start = is_l.getBegin();
      Index_type const l_end   = is_l.getEnd();

#pragma omp parallel for schedule(static) collapse(4)
      for(Index_type i = i_start;i < i_end;++ i){
        for(Index_type j = j_start;j < j_end;++ j){
          for(Index_type k = k_start;k < k_end;++ k){
            for(Index_type l = l_start;l < l_end;++ l){
              body(i, j, k, l);
      } } } } 
    }
};

// OpenMP Executor with collapse(2) for omp_for_nowait_exec
template<typename POLICY_K, typename POLICY_L, typename TK, typename TL>
class Forall4Executor<RAJA::omp_for_nowait_exec, RAJA::omp_for_nowait_exec, POLICY_K, POLICY_L, RAJA::RangeSegment, RAJA::RangeSegment, TK, TL> {
  public:  
    template<typename BODY>
    inline void operator()(RAJA::RangeSegment const &is_i, RAJA::RangeSegment const &is_j, TK const &is_k, TL const &is_l, BODY body) const {
      Index_type const i_start = is_i.getBegin();
      Index_type const i_end   = is_i.getEnd();

      Index_type const j_start = is_j.getBegin();
      Index_type const j_end   = is_j.getEnd();

#pragma omp for schedule(static) collapse(2) nowait
      for(Index_type i = i_start;i < i_end;++ i){
        for(Index_type j = j_start;j < j_end;++ j){
          exec(is_k, is_l, RAJA_LAMBDA(Index_type k, Index_type l){
            body(i, j, k, l);
          });
      } } 
    }

  private:
    Forall2Executor<POLICY_K, POLICY_L, TK, TL> exec;
};

// OpenMP Executor with collapse(3) for omp_for_nowait_exec
template<typename POLICY_L, typename TL>
class Forall4Executor<RAJA::omp_for_nowait_exec, RAJA::omp_for_nowait_exec, RAJA::omp_for_nowait_exec, POLICY_L, RAJA::RangeSegment, RAJA::RangeSegment, RAJA::RangeSegment, TL> {
  public:  
    template<typename BODY>
    inline void operator()(RAJA::RangeSegment const &is_i, RAJA::RangeSegment const &is_j, RAJA::RangeSegment const &is_k, TL const &is_l, BODY body) const {
      Index_type const i_start = is_i.getBegin();
      Index_type const i_end   = is_i.getEnd();

      Index_type const j_start = is_j.getBegin();
      Index_type const j_end   = is_j.getEnd();

      Index_type const k_start = is_k.getBegin();
      Index_type const k_end   = is_k.getEnd();

#pragma omp for schedule(static) collapse(3) nowait
      for(Index_type i = i_start;i < i_end;++ i){
        for(Index_type j = j_start;j < j_end;++ j){
          for(Index_type k = k_start;k < k_end;++ k){
            RAJA::forall<POLICY_L>(is_l, RAJA_LAMBDA(Index_type l){
              body(i, j, k, l);
            });
      } } } 
    }
};

// OpenMP Executor with collapse(4) for omp_for_nowait_exec
template<>
class Forall4Executor<RAJA::omp_for_nowait_exec, RAJA::omp_for_nowait_exec, RAJA::omp_for_nowait_exec, RAJA::omp_for_nowait_exec, RAJA::RangeSegment, RAJA::RangeSegment, RAJA::RangeSegment, RAJA::RangeSegment> {
  public:  
    template<typename BODY>
    inline void operator()(RAJA::RangeSegment const &is_i, RAJA::RangeSegment const &is_j, RAJA::RangeSegment const &is_k, RAJA::RangeSegment const &is_l, BODY body) const {
      Index_type const i_start = is_i.getBegin();
      Index_type const i_end   = is_i.getEnd();

      Index_type const j_start = is_j.getBegin();
      Index_type const j_end   = is_j.getEnd();

      Index_type const k_start = is_k.getBegin();
      Index_type const k_end   = is_k.getEnd();

      Index_type const l_start = is_l.getBegin();
      Index_type const l_end   = is_l.getEnd();

#pragma omp for schedule(static) collapse(4) nowait
      for(Index_type i = i_start;i < i_end;++ i){
        for(Index_type j = j_start;j < j_end;++ j){
          for(Index_type k = k_start;k < k_end;++ k){
            for(Index_type l = l_start;l < l_end;++ l){
              body(i, j, k, l);
      } } } } 
    }
};


#endif // _OPENMP


/******************************************************************
 *  forall4_permute(): Permutation function overloads
 ******************************************************************/

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_IJKL, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyI, PolicyJ, PolicyK, PolicyL>(NextPolicyTag(), is_i, is_j, is_k, is_l,
    RAJA_LAMBDA(Index_type i, Index_type j, Index_type k, Index_type l){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_IJLK, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyI, PolicyJ, PolicyL, PolicyK>(NextPolicyTag(), is_i, is_j, is_l, is_k,
    RAJA_LAMBDA(Index_type i, Index_type j, Index_type l, Index_type k){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_IKJL, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyI, PolicyK, PolicyJ, PolicyL>(NextPolicyTag(), is_i, is_k, is_j, is_l,
    RAJA_LAMBDA(Index_type i, Index_type k, Index_type j, Index_type l){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_IKLJ, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyI, PolicyK, PolicyL, PolicyJ>(NextPolicyTag(), is_i, is_k, is_l, is_j,
    RAJA_LAMBDA(Index_type i, Index_type k, Index_type l, Index_type j){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_ILJK, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyI, PolicyL, PolicyJ, PolicyK>(NextPolicyTag(), is_i, is_l, is_j, is_k,
    RAJA_LAMBDA(Index_type i, Index_type l, Index_type j, Index_type k){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_ILKJ, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyI, PolicyL, PolicyK, PolicyJ>(NextPolicyTag(), is_i, is_l, is_k, is_j,
    RAJA_LAMBDA(Index_type i, Index_type l, Index_type k, Index_type j){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_JIKL, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyJ, PolicyI, PolicyK, PolicyL>(NextPolicyTag(), is_j, is_i, is_k, is_l,
    RAJA_LAMBDA(Index_type j, Index_type i, Index_type k, Index_type l){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_JILK, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyJ, PolicyI, PolicyL, PolicyK>(NextPolicyTag(), is_j, is_i, is_l, is_k,
    RAJA_LAMBDA(Index_type j, Index_type i, Index_type l, Index_type k){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_JKIL, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyJ, PolicyK, PolicyI, PolicyL>(NextPolicyTag(), is_j, is_k, is_i, is_l,
    RAJA_LAMBDA(Index_type j, Index_type k, Index_type i, Index_type l){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_JKLI, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyJ, PolicyK, PolicyL, PolicyI>(NextPolicyTag(), is_j, is_k, is_l, is_i,
    RAJA_LAMBDA(Index_type j, Index_type k, Index_type l, Index_type i){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_JLIK, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyJ, PolicyL, PolicyI, PolicyK>(NextPolicyTag(), is_j, is_l, is_i, is_k,
    RAJA_LAMBDA(Index_type j, Index_type l, Index_type i, Index_type k){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_JLKI, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyJ, PolicyL, PolicyK, PolicyI>(NextPolicyTag(), is_j, is_l, is_k, is_i,
    RAJA_LAMBDA(Index_type j, Index_type l, Index_type k, Index_type i){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_KIJL, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyK, PolicyI, PolicyJ, PolicyL>(NextPolicyTag(), is_k, is_i, is_j, is_l,
    RAJA_LAMBDA(Index_type k, Index_type i, Index_type j, Index_type l){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_KILJ, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyK, PolicyI, PolicyL, PolicyJ>(NextPolicyTag(), is_k, is_i, is_l, is_j,
    RAJA_LAMBDA(Index_type k, Index_type i, Index_type l, Index_type j){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_KJIL, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyK, PolicyJ, PolicyI, PolicyL>(NextPolicyTag(), is_k, is_j, is_i, is_l,
    RAJA_LAMBDA(Index_type k, Index_type j, Index_type i, Index_type l){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_KJLI, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyK, PolicyJ, PolicyL, PolicyI>(NextPolicyTag(), is_k, is_j, is_l, is_i,
    RAJA_LAMBDA(Index_type k, Index_type j, Index_type l, Index_type i){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_KLIJ, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyK, PolicyL, PolicyI, PolicyJ>(NextPolicyTag(), is_k, is_l, is_i, is_j,
    RAJA_LAMBDA(Index_type k, Index_type l, Index_type i, Index_type j){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_KLJI, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyK, PolicyL, PolicyJ, PolicyI>(NextPolicyTag(), is_k, is_l, is_j, is_i,
    RAJA_LAMBDA(Index_type k, Index_type l, Index_type j, Index_type i){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_LIJK, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyL, PolicyI, PolicyJ, PolicyK>(NextPolicyTag(), is_l, is_i, is_j, is_k,
    RAJA_LAMBDA(Index_type l, Index_type i, Index_type j, Index_type k){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_LIKJ, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyL, PolicyI, PolicyK, PolicyJ>(NextPolicyTag(), is_l, is_i, is_k, is_j,
    RAJA_LAMBDA(Index_type l, Index_type i, Index_type k, Index_type j){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_LJIK, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyL, PolicyJ, PolicyI, PolicyK>(NextPolicyTag(), is_l, is_j, is_i, is_k,
    RAJA_LAMBDA(Index_type l, Index_type j, Index_type i, Index_type k){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_LJKI, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyL, PolicyJ, PolicyK, PolicyI>(NextPolicyTag(), is_l, is_j, is_k, is_i,
    RAJA_LAMBDA(Index_type l, Index_type j, Index_type k, Index_type i){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_LKIJ, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyL, PolicyK, PolicyI, PolicyJ>(NextPolicyTag(), is_l, is_k, is_i, is_j,
    RAJA_LAMBDA(Index_type l, Index_type k, Index_type i, Index_type j){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}

template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_permute(PERM_LKJI, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // Call next policy with permuted indices and policies
  forall4_policy<NextPolicy, PolicyL, PolicyK, PolicyJ, PolicyI>(NextPolicyTag(), is_l, is_k, is_j, is_i,
    RAJA_LAMBDA(Index_type l, Index_type k, Index_type j, Index_type i){
      // Call body with non-permuted indices
      body(i, j, k, l);
    });
}


/******************************************************************
 *  forall4_policy() Policy Layer, overloads for policy tags
 ******************************************************************/


/**
 * Execute inner loops policy function.
 * This is the default termination case.
 */
    template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_policy(Forall4_Execute_Tag, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){

  // Create executor object to launch loops
  Forall4Executor<PolicyI, PolicyJ, PolicyK, PolicyL, TI, TJ, TK, TL> exec;

  // Launch loop body
  exec(is_i, is_j, is_k, is_l, body);
}


/**
 * Permutation policy function.
 * Provides loop interchange.
 */
    template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_policy(Forall4_Permute_Tag, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  // Get the loop permutation
  typedef typename POLICY::LoopOrder LoopOrder;

  // Call loop interchange overload to re-wrire indicies and policies
  forall4_permute<POLICY, PolicyI, PolicyJ, PolicyK, PolicyL>(LoopOrder(), is_i, is_j, is_k, is_l, body);
}


/**
 * OpenMP Parallel Region Section policy function.
 */
    template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_policy(Forall4_OMP_Parallel_Tag, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;

  // create OpenMP Parallel Region
#ifdef _OPENMP
#pragma omp parallel
#endif
  {
    // execute the next policy
    forall4_policy<NextPolicy, PolicyI, PolicyJ, PolicyK, PolicyL>(NextPolicyTag(), is_i, is_j, is_k, is_l, body);
  }
}


/**
 * Tiling policy function.
 */
    template<typename POLICY, typename PolicyI, typename PolicyJ, typename PolicyK, typename PolicyL, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4_policy(Forall4_Tile_Tag, TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  typedef typename POLICY::NextPolicy            NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;
  typedef typename POLICY::TileI TileI;
  typedef typename POLICY::TileJ TileJ;
  typedef typename POLICY::TileK TileK;
  typedef typename POLICY::TileL TileL;

  // execute the next policy
      forall_tile(TileI(), is_i, [=](RAJA::RangeSegment is_ii){
        forall_tile(TileJ(), is_j, [=](RAJA::RangeSegment is_jj){
          forall_tile(TileK(), is_k, [=](RAJA::RangeSegment is_kk){
            forall_tile(TileL(), is_l, [=](RAJA::RangeSegment is_ll){
          forall4_policy<NextPolicy, PolicyI, PolicyJ, PolicyK, PolicyL>(NextPolicyTag(), is_ii, is_jj, is_kk, is_ll, body);
            });
          });
        });
      });
}



/******************************************************************
 * forall4(), User interface
 * Provides index typing, and initial nested policy unwrapping
 ******************************************************************/

template<typename POLICY, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxK=Index_type, typename IdxL=Index_type, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE void forall4(TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY body){
  // extract next policy
  typedef typename POLICY::NextPolicy             NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag  NextPolicyTag;

  // extract each loop's execution policy
  typedef typename POLICY::PolicyI                PolicyI;
  typedef typename POLICY::PolicyJ                PolicyJ;
  typedef typename POLICY::PolicyK                PolicyK;
  typedef typename POLICY::PolicyL                PolicyL;

  // call 'policy' layer with next policy
  forall4_policy<NextPolicy, PolicyI, PolicyJ, PolicyK, PolicyL>(NextPolicyTag(), is_i, is_j, is_k, is_l, 
    [=](Index_type i, Index_type j, Index_type k, Index_type l){
      body(IdxI(i), IdxJ(j), IdxK(k), IdxL(l));
    }
  );
}



} // namespace RAJA
  
#endif

