#!/usr/bin/env python
#
# Copyright (c) 2016, Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory.
#
# All rights reserved.
#
# This source code cannot be distributed without permission and
# further review from Lawrence Livermore National Laboratory.
#


import sys
from itertools import permutations
from lperm import *


def writeForallPolicy(ndims):
  
  dim_names = getDimNames(ndims)
  
  print "// Tiling Policy"
  print "struct Forall%d_Tile_Tag {};" % ndims
  args = map(lambda a: "typename TILE_"+(a.upper()), dim_names)
  argstr = ", ".join(args)
  print "template<%s, typename NEXT=Forall%d_Execute>" % (argstr, ndims)
  print "struct Forall%d_Tile {" % ndims
  print "  typedef Forall%d_Tile_Tag PolicyTag;" % ndims
  print "  typedef NEXT NextPolicy;"
  for dim in dim_names:
    print "  typedef TILE_%s Tile%s;" % (dim.upper(), dim.upper())
  print "};"
  print ""
  

   

def writeForall_policy(ndims):
  
  dim_names = getDimNames(ndims)
  
  # Create boiler-plate used for all _policy() fcns
  polstr = ", ".join(map(lambda a: "typename Policy"+a.upper(), dim_names))
  setstr = ", ".join(map(lambda a: "typename T"+a.upper(), dim_names))
  isstr = ", ".join(map(lambda a: "T%s const &is_%s"%(a.upper(), a) , dim_names))

  template_string = "template<typename POLICY, %s, %s, typename BODY>" % (polstr, setstr)
  fcnargs_string = "%s, BODY body" % isstr
  
  polstr  = ", ".join(map(lambda a: "Policy"+a.upper(), dim_names))
  typestr = ", ".join(map(lambda a: "T"+a.upper(), dim_names))
  varstr = ", ".join(map(lambda a: "is_"+a, dim_names))
  
  print ""
  print "/*!"
  print " * \\brief Tiling policy function."
  print " */"
  print template_string
  print "RAJA_INLINE void forall%d_policy(Forall%d_Tile_Tag, %s){" % (ndims, ndims, fcnargs_string)
  print "  typedef typename POLICY::NextPolicy            NextPolicy;"
  print "  typedef typename POLICY::NextPolicy::PolicyTag NextPolicyTag;"
  for d in dim_names:
    print "  typedef typename POLICY::Tile%s Tile%s;" % (d.upper(), d.upper())
  print ""
  print "  // execute the next policy"
  
  indent = ""
  close_paren = []
  for d in dim_names:
    print "%s      forall_tile(Tile%s(), is_%s, [=](RAJA::RangeSegment is_%s%s){" % (indent, d.upper(), d, d, d)
    close_paren.append(indent + "      });")
    indent += "  "

  # call body with tiled index sets
  t_varstr = ", ".join(map(lambda a: "is_"+a+a, dim_names))
  print "%s  forall%d_policy<NextPolicy, %s>(NextPolicyTag(), %s, body);" % (indent, ndims, polstr, t_varstr)

  # close forall parenthesis
  close_paren.reverse()
  for c in close_paren:
    print c

  print "}"
  print ""
  print ""
  



def main(ndims):
  # ACTUAL SCRIPT ENTRY:
  print """//AUTOGENERATED BY gen_forallN_generic.py
/*
 * Copyright (c) 2016, Lawrence Livermore National Security, LLC.
 * Produced at the Lawrence Livermore National Laboratory.
 *
 * All rights reserved.
 *
 * This source code cannot be distributed without permission and
 * further review from Lawrence Livermore National Laboratory.
 */
  
#ifndef RAJA_forallN_tile_HXX__
#define RAJA_forallN_tile_HXX__

#include"config.hxx"
#include"int_datatypes.hxx"

namespace RAJA {

""" 
  ndims_list = range(2,ndims+1)
  
  # Create the policy struct so the user can define loop policies
  print ""
  print "/******************************************************************"
  print " *  ForallN tiling policies"
  print " ******************************************************************/"
  print ""
  for n in ndims_list:
    writeForallPolicy(n)


  # Create _policy functions
  print ""
  print "/******************************************************************"
  print " *  forallN_policy(), tiling execution"
  print " ******************************************************************/"
  print ""
  for n in ndims_list:
    writeForall_policy(n)


  print """

} // namespace RAJA
  
#endif
"""

if __name__ == '__main__':
  main(int(sys.argv[1]))
  
